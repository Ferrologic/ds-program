---
title: "BLOCK 4: UNSUPERVISED LEARNING"
author: "Niklas Johnson & Helena Ahlin"
date: '2019-01-04'
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

En vinproducent har analyserat 13 olika kemiska egenskaper hos 178 av de italienska viner de saluför. Vinerna är av tre olika typer och man vill nu se om det är möjligt att på ett datadrivet sätt skapa bra grupperingar av vinerna.
Till ditt förfogande har du datasetet wine  med följande kategorier:

Kolumnnamn                   | Beskrivning                       
-----------------------------|-------------------------------------
Type	                       | Vinets typ
Alcohol	                     | Alkoholinnehåll (%)
Malic Acid	                 | Koncentration av äppelsyra
Ash	                         | Mineralitet
Alcalinity of Ash            | Alkalinitet i mineralinnehållet
Magnesium	                   | Magnesiuminnehåll
Total Phenols	               | Totalinnehåll fenoler
Flavanoids	                 | Flavanoider
Nonflavanoids	               | Icke-flavanoider
Proanthocyanins              | Proanthocyaniner
Color intensity              | Färgintensitet
Hue	                         | Färgton
OD280/OD315 of diluted wines | OD280/OD315 hos spädda viner (OD: optisk densitet)
Proline	                     | Prolininnehåll



Till övningen behöver du två paket: `ggplot2` och `cluster`. Ggplot2 är ett kraftfullt paket för visualisering och cluster tillgängliggör funktioner för segmentering. Börja med att installera och ladda paketen:

```{r}
install.packages("ggplot2")
install.packages("cluster")
library(ggplot2)
library(cluster)
```


### Läs in data
Läs in data genom att utnyttja funktionen `read_delim()` som finns i paketet `readr`. `read_delim()` fungerar på filer där du har en speciell separator, exempelvis `";"`. `read_csv` fungerar för filer med "," som separator. Det finns lite olika alternativ till encoding. Testa att läsa in filerna utan att ange encoding och se om all text ser bra ut. Om inte kan du testa `"mac"`, `"utf-8"`, `"ansii"`, `"windows-1252"`.
Du hittar tabellen här: https://github.com/Ferrologic/ds-program/tree/master/block4. 
 
Klicka på länken, därefter på filen och sedan på `Raw`. Markera och kopiera in länken i `read_delim()` nedan så slipper ni lagra csv-filen på datorn, ni läser in den direkt från github. 
 
```{r}
library(tidyverse)
Wine <- read_delim("https://raw.githubusercontent.com/Ferrologic/ds-program/master/block4/wine.csv", delim = ";")
```

Kontrollera därefter variabelnamn och datatyp, samt titta på data:

```{r}
  names(Wine)
  str(Wine)
  class(Wine)
```

Vilken datatyp har ditt data? Ser importen ut att ha gått bra?


Alla variabler i detta dataset ska vara numeriska vilket du enkelt kan kontrollera antingen genom att titta på resultatet från `str()` ovan (”num” på alla rader) eller genom att ställa en fråga till R. Får du ett annat svar än TRUE har importen troligen inte gått bra.

```{r}
  is.numeric(as.matrix(Wine[,2:14]))
```



## Övning 1
Kontrollera om datasetet saknar värden för några mätningar. Det finns många olika sätt att kontrollera missing, ett sätt är att skriva en enkel funktion och använda den: 

```{r}
# Kontrollera om det finns missing values (NA) i din data
  sapply(Wine, function(x) sum(is.na(x)))

# Om du hittar några missing values, imputera dessa värden med hjälp av medelvärdet
  Wine$Magnesium[is.na(Wine$Magnesium)] <-  
  mean(Wine$Magnesium, na.rm=T)
```



## Övning 2
För att i slutet av analysen kunna kontrollera om vår segmentering är relevant vill vi spara vintypindelningen till detta. Spara därför denna separat och tar bort den från övriga variabler:


```{r}
  vintyp <- subset(Wine, select=Type)
  Wine <- subset(Wine, select = -Type)
```



## Övning 3
För att segmenteringen ska falla ut väl, behöver de numeriska kolumnerna standardiseras så at de alla ligger på samma skala. Använd scale-funktionen och lagra resultatet i en dataframe:

```{r}
NyttWine <- as.data.frame(scale(Wine))
```


## Övning 4
Ett sätt att se vilket antal grupper som skulle kunna vara lämpligt för data är att plotta upp kvadratsumman inom gruppen mot antal grupper. Iterera över en serie grupper, exemplet nedan visar 2 till 10 grupper:
```{r}
# Loopa från 2 till 10 grupper
  wss <- (nrow(NyttWine)-1)*sum(apply(NyttWine,2,var))

for (i in 2:10) wss[i] <- sum(kmeans(NyttWine, centers=i)$withinss)


# Plotta resultatet
  plot(1:10, wss, type="b", xlab="Number of Clusters",
    	     ylab="Within groups sum of squares")
```

Med utgångspunkt i plotten, hur många grupper tycker du vinerna bör delas in i?


## Övning 5
Anpassa en segmenteringsmodell genom att använda kmeans-funktionen, använd det antal grupper du valde i övning 4:

```{r}
Segmodell <- kmeans(NyttWine, 3) 
```




## Övning 6
Ta fram medelvärden för de olika förklaringsvariablerna per segment genom att använda aggregate-funktionen:

```{r}
aggregate(NyttWine,by=list(Segmodell$cluster),FUN=mean)
```

Vad kan du säga om segmenten utifrån de olika medelvärdena? 


## Övning 7
Ett sätt att rita upp segmenten är att använda clusplot-funktionen i cluster-paketet. Bilden visar segmenten uppritade mot den första och den andra principalkomponenten:


```{r}
install.packages("cluster")
library(cluster)
  clusplot(NyttWine, Segmodell$cluster, color=TRUE, shade=TRUE, 
           labels=2, lines=0)
```


Är du nöjd med antalet segment? Om inte, gör om din analys tills du är nöjd.


## Övning 8

När du är nöjd med dina segment är det en bra idé att lagra vinernas grupptillhörighet i data så att du kan använda segmenten i framtida analyser:

```{r}
vintyp$kmeans <- Segmodell$cluster
```


## Övning 9
Vi kan nu kontrollera hur väl vår segmentering stämmer överens med det vi redan visste om vinerna, dvs deras ”typ”:


```{r}
 table(vintyp$Type, vintyp$kmeans)
```

Ser det ut som du förväntat dig? Hamnar alla viner i ”rätt” kluster?


## Övning 10
Vi kan också visualisera matchningen i en plot liknande den du gjorde med funktionen clusplot ovan. Den funktionen använder först principalkomponentanalys (PCA) för att fånga så mycket av möjligt av variationen i data med så få dimensioner som möjligt. `clusplot()` använder funktionen `princomp()` i R så det gör vi också:

```{r}
# Gör en PCA på ditt standardiserade data
PCA <- princomp(NyttWine)

# Titta på vad detta objekt innehåller
attributes(PCA)
summary(PCA)
```



Vi vill, precis som clusplot gör, plotta första principalcomponenten mot den andra. Först sparar vi över alla komponenter i ett nytt dataset:
```{r}
PC <- PCA$scores
```

För att underlätta visualiseringen skapar vi en ny variabel, sammansatt av både vinets typ och dess Kmeans-kluster, sedan använder vi ggplot2 -paketet för att skapa vår plot:
```{r}
vintyp$TypVskmeans <- paste(vintyp$Type, vintyp$kmeans, sep = "vs")
  
# Denna rad talar om att ggplot ska använda kolumnerna Comp.1 och Comp.2 från datasetet PC
  ggplot(as.data.frame(PC), aes(x=Comp.1, y=Comp.2))+
# denna rad talar om att ggplot ska rita en scatterplot av data 
# och ge punkterna färg och form efter variabeln TypVskmeans vi skapade #tidigare  
  geom_point(size =2, aes(color = vintyp$TypVskmeans, 
                          shape =vintyp$TypVskmeans))+
#följande rader formaterar utseendet på plotten och lägger till titlar
          theme_bw()+
          labs(title ="Cluster visualization", shape = "Vintyp_Clusternr",
          color = "Vintyp_Clusternr")+
          theme(plot.title = element_text(hjust = 0.5))

```

Tycker du segmenteringen ser ut rimlig ut? Är klustren tydligt separerade från varandra? Vad kan du säga om eventuella felsegmenterade viner?
